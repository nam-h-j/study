## 함수
### 함수의 개념
- 특정 작업을 수행하는 프로그램 문장들을 하나의 단위로 모아놓고 이름을 부여한 것
- 프로그램 해석 할 때의 가독성
- 반복 기능의 재사용 및 일괄 수정
- 매개변수를 통해 인수를 전달 -> 함수 블록을 내용을 수행 -> 결과값 반환
### 함수 사용 형식
```c++
RetureType FunctionName(FunctionParameterList)
{
  Type LocalVar //지역변수 선언가능
  ...
  do something
  ...
  return returnExpression //결과값 반환
}
```
- return
  - 함수를 마치고 함수를 호출한 곳으로 복귀하는 명령
  - 함수 안의 어느 곳이든 복귀를 위해 사용 가능
  - 함수의 리턴타입과 리턴값의 자료형은 동일해야함, 또는 묵시적 형변환이 가능한 자료형 수식을 사용
  - 리턴값이 없으면 함수 타입을 void로 선언
  - main 함수에서 끝에 return 명령을 작성하지 않으면 'return 0;' 을 실행한 것과 같음

- c++ 함수작성시 주의점
  - 함수를 사용하기 전에 선언해야 한다.
  - 만약 함수 정의부를 코드의 아래로 보내려면 함수의 원형을 미리 선언해주면 된다.
  - 함수의 원형
  ```
    ReturnType FunctionName(Parameters);
  ```
### 함수의 순환 호출(재귀함수)
- 함수 내부에서 함수 자신을 다시 호출하는 것
- 순환호출 예제 (팩토리얼)
```c++
int factorial(int n)
{
  if(n <= 1)
    return 1;
  else
    return n * factorial(n - 1); //순환호출함
}
```
### 함수의 장점과 단점
- 장점
  - 크고 복잡한 프로그램을 작은 크기의 의미 있는 작업단위로 분할하여 구성
    - 간결하고 이해하기 쉬운 프로그램을 만들 수 있음
  - 코드 중복 방지
  - 잘 설계된 함수는 다른 프로그램에도 재사용 가능
- 단점
  - 함수 호출과 복귀 과정에서 처리 시간이 추가됨(대부분 크게 영향은 주지 않는다)
  - 자주 호출되어야 해서 효율적으로 동작해야 하는 함수라면 inline함수로 선언
  
### 인수와 매개변수
- 인수
  - 함수 호출 문장에서 함수에 전달하는 식
    - 여러개의 인수가 있을 경우 콤마(,)로 구분하여 나열
  - 실 매개변수
    - 함수 호출 문장에서 함수의 형식 매개변수에 전달할 "인수"
  - 형식 매개변수
    - 인수를 전달 받기 위해 함수에 선언된 매개 변수
    - 함수 헤더에 매개변수의 자료형과 이름을 선언함
### 인수 전달 방식
  - 값 호출(call-by-value)
    - 실 매개변수의 값을 형식 매개변수에 복사하는 방식
    - 장점
      - 실매개변수와 매개변수는 별개의 데이터가 되므로 불필요한 부작용이 발생하지 않음
    - 단점
      - 구조체와 같이 많은 양의 데이터로 구성된 인수를 전달할 경우 데이터의 복사량이 많아짐
  - 참조 호출(call-by-reference)
    - 실 매개변수의 "참조"를 형식 매개변수에 전달하는 방식
    - 포인터를 전달해도 되지만 작성에 어려움이 있어서 참조를 전달 함
    - 함수에 처리한 결과를 매개변수를 통해 받아 오려는 경우
    - 참조호출의 용도
      - 함수에서 처리한 결과를 매개변수를 통해 받아오려는 경우
        - 함수에서 형식 매개변수의 값을 변경하는 것은 실 매개변수의 값을 변경하는 것과 같음
      - 많은 양의 데이터로 구성되는 구조체나 객체와 같은 인수를 함수에 효율적으로 전달하는 경우
        - 형식 매개변수에 복사되는 데이터의 양은 실 매개변수의 크기와 관계 없이 일정함
        ```c++
        void SwapValues(int& x, int& y); //참조형으로 선언
        ```
   - const 한정어 지정 : 참조호출을 하지만 실 매개변수의 값이 변경되는 것을 원하지 않을경우
   ```c++
   struct SalesRec{
    char pID[10];
    int dYear, dMonth, dDate;
    char deliverAddr[40];
   }
   void PrSalseRec(const SalesRec &srec) //const 한정어를 사용하면 실매개변수 값이 보호됨
   {
    ...
   }
   ```
### 디폴트 인수
- 일반적으로 사용되는 디폴트 값이 있는 인수의 경우 함수를 정의할 때 그 값을 미리 지정할 수 있음
```c++
istrean& getLine(char* str, int count, char delimiter='\n');
char str1[10], str2[10]
cin.getLine(str1, 10, ',')
cin.getLine(str2, 10); //delimiter에 디폴트값 '\n'을 사용함
```
- 디폴트 인수는 인수 중 끝에만 위치할 수 있음
```c++
void f(int x, int y=10, int z=20); //ok
void g(int x, int y=10, int z); //err

f(5); //x=5, y=10, z=20
f(5, 100); //x=5, y=100, z=20
f(5, 100, 200); //x=5, y=100, z=200
f(5, , 300); //err, f(5, 20, 300)으로 작성해야함.
```

### 함수의 다중정의(overloading)
- 동일한 이름에 대하여 여러가지 의미를 부여하는 것
- 동일한 이름을 갖는 함수를 여러 개 정의하는 것
- 동일한 개념의 처리를 여러 가지 데이터나 객체에 대해 각각의 대상에 맞는 처리를 해야 할 경우 사용함
- 다중정의된 함수의 구분 : **인수의 개수 및 자료형**
  - 함수의 반환 자료형으로 함수를 구분할 수 없음.
- 함수의 잘못된 다중정의
  ```c++
  //1. 만약 리턴 타입만 다르게 해서 다중정의를 하면 컴파일 에러가 발생함
  void f(int a) 
  {
    cout<< a * a;
  }
  int f(int a) //컴파일 에러!!
  {
    cout<< a * a;
    return a
  }
  
  //2. 만약 다중정의에 디폴트 인수가 있을때 컴파일 에러가 난다
  void f(int a)
  {
    cout << a + a;
  }
  void f(int a, int b=100)
  {
    cout << a + b;
  }
  
  int main()
  {
    f(10, 20); //두번째 함수를 호출함
    f(10); //컴파일 에러 (두 함수 모두 해당되는 호출 방법이기 때문)
  }
  
  //3. 묵시적 형변환 대상이 모호할때
  void f(int a)
  {
    cout << a + a;
  }
  void f(float a)
  {
    cout << a + a;
  }
  
  int main()
  {
    f(10); //첫번째 함수를 호출함 int로 변환
    f(10.0f); //두번째 함수를 호출함 float으로 변환
    f(10.0); //컴파일에러(int인지, float인지, double인지 알수 없음, 묵시적 형변환이 안됨)
  }
  ```
### inline함수
- inline(인라인)함수란?
  - 함수 호출 절차를 따르지 않고 함수 호출 위치에 함수의 처리 문장이 삽입되게 번역하도록 선언된 함수
  - 함수를 사용함으로써 얻을 수 있는 모듈화를 살리면서 호출에 사용되는 부수적인 처리시간이 생략
  - 함수 호출 루틴으로부터 함수로 넘어가는 부분의 코드 최적화가 가능해짐
  - 빈번히 호출되며 빠른 실행이 요구되는 함수를 인라인 함수로 선언하면 성능을 높이는데 도움이 됨
  - 인라인으로 선언하더라도 반드시 인라인으로 번역되는 것은 아님
    - 함수가 너무 큰 경우
    - 순환 호출(재귀)하는 경우
    - 프로그램 내에서 그 함수에 대한 포인터를 사용하는 경우
