## C++기초
### 키워드
  - 미리 용도를 정해놓고 제공하는 단어
  - #include, using, namespace, int, return ...
### 식별자
  - 변수명 함수명 클래스명 등
  - 규칙
    - 첫 글자 = 영문 대/소문자, \_ (MS C++에서는 '$'도 가능, c++11부터는 다국어 문자 지원)
    - 이후 문자 = 문자, 숫자, 특수문자 안됨
    - 길이 제한 없음
    - 키워드 사용 불가
    - 대소문자 구분함
    - '\_'로 시작하는 이름은 안쓰는게 좋음
    - 마소 c++에서는 $로 시작하는 경우가 많음
    - snake_case
    - camelCase
    - PascalCase
### 자료형
  - 기본자료형
    - 정수형 : char, int, short, long, bool ...
    - 실수형 : float, double, long double
  - 복합자료형
    - 배열, 구조체, 클래스, 열거형, 공용체
    - 포인터, 참조
### 기본자료형
  - 정수 자료형(integral types)
    - 문자 : char
    - 정수 : int, short, long, long long
    - 부울 : bool
    - 유니코드 : wchar_t, char16_t, char32_t
  - 실수 자료형
    - 부동소수점 방식
    - float (4byte)
      - 부호 1비트, 지수부 8비트, 가수부 23비트
      - 1.17549 * 10^38 ~ 3.40282 * 10^38
    - double (8byte)
      - 부호 1비트, 지수부 11비트, 가수부 52비트
      - 2.22507 * 10^308 ~ 1.79769 * 10^308
    - climits.h
      - numeric_limits<float>::min() 최소값
      - numeric_limits<float>::max() 최대값
  - 정수형 리터럴(int)
    - 접두사의 의미  
      - 접두사 없음 : 10진수 [ex) 123]
      - 0b : 2진수(binary) [ex) 0b1011]
      - 0 : 8진수 [ex) 0123]
      - 0x : 16진수 [ex) 0xAF]
    - 접미사
      - 접미사 없음 : 123, int형
      - u : 123u, unsigned int형
      - l : 123l, long형
      - ul : 123ul, unsigned long형
      - ll : 123ll, long long형
  - 문자 리터럴
    - A : 문자 'A', ASCII 65
    - \101 : 문자 'A', ASCII 65의 8진수
    - \x41 : 문자 'A', ASCII 65의 16진수
  - 실수형 리터럴
    - double 1200 : 1200. / 1200.0 / 12e2 / 1.2e+3
    - float 1200 : 1200.0f / 12e2f
  
### 변수
  - 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역
  - 자료형과 변수명
  - 사용전에 미리 선언
  - 변수 초기화
    - int num = 0;
    - int num(0);
    - int num{0};
  - 자료형 추론
    - auto i(10); = int i(10)
  - 변수 스코프

  ```c++
  int a; //전역 스코프
  extern int a; // 다른 소스파일의 전역 변수를 쓸때
  static int b{10}; //선언한 파일내에서만 접근
  int f(){
    int c{20}, d{30}//블록 스코프
    {
      int d{40} //이름가리기(namehide): 외부 블록과 같은 변수 이름으로 선언하면 외부 변수는 사용이 안되는 현상
    }
  }
  ```
    - 한정어
      - const
        - 상수 선언(값 수정이 안됨)
        - 초기화를  통해서만 값을 정할 수 있다.
      - constexpr
        - 컴파일할 때 상수의 값을 평가(정함)
        -
  ```c++
  int a;
  std::cin >> a;
  const int b = 20;
  
  const int C1 = a; //cin으로 입력된 a의 값으로 할당됨
  constexpr int C2 = a + 1; //err : 컴파일시에 a의 값이 없기 때문에 에러
  constexpr int C3 = b + 1; // 정상적으로 컴파일
  constexpr int C4 = C1 + 1; // err : 컴파일시에 값이 없기 때문에 에러
  ```
  ```c++
  //팩토리얼 예제에서 constexpr의 동작
  constexpr int fac(int n){
    return n > 1 ? n * fac(n - 1) : 1;
  }
  void f(int x) {
    constexpr int a = fac(4); //컴파일때 계산
    int b = fac(x) // 실행 중 계산
  }
  ```
### 변수의 유효기간
- 변수가 만들어져서 없어지는 시점
  - 자동변수
      - 생성시점 : 함수(블록)가 시작될 때
      - 소멸시점 : 함수(블록)가 종료될 때
  - 정적변수
    - 생성시점 : 프로그램이 시작될 때
    - 소멸시점 : 프로그램이 종료될 때
```c++
int x; // 전역변수 - 정적변수
int f(){
  int y{10}; // 지역변수 - 자동변수
  static int z{0}; // 정적 지역변수 - 정적변수
}
```
### 산술연산자
- 2항 연산자
   - 사칙연산 : +. -, *, /
   - 나머지연산 : %
- 단항 연산
    - 증감 연산
  ```c++
  int a = 10;
  int b = ++a; // a = 11, b = 11
  int c = a++; // a = 11, c = 10
  int d = --a; // a = 9, d = 9
  int e = a--; // a = 9, e = 10
  ```
### 대입 연산자
  - 결합방향 : 오른쪽에서 왼쪽으로
```c++
  int a = 0; // a = 0
  int b = int c = 0; // b = 0, c = 0
  double d = int e = 1.5; // d = 1, e = 1 오른쪽 변수에 먼저 값이 들어가기 때문에 소숫점이 버려진 값이 d에 할당 됨
```
### 복합 대입 연산자
  - 이항연산자와 대입 연산자를 결합
```c++
  a += b; // a = a + b; 와 같다
```
### 관계연산
  - <, >, <=, >=, ==, !=
### 논리연산
  - ||(OR, 논리합), &&(AND, 논리곱), !(NOT, 부정)
  - 왼쪽항 계산 결과에 따라 결과가 정해지면 오른쪽 항 계산 하지 않음
### 비트연산
   - 비트 논리 연산
    - |(논리합), &(논리곱), ^(배타적 논리 합[비트반전]), ~(부정)
   - 비트 이동 연산(시프트연산)
    - 좌측이동
      - <<
      - 좌측으로 2비트씩 이동, 비는 부분은 0으로 채워짐, 넘치는 부분은 버림
      - 원래 값의 * 4(2^2)를 하는 효과
    - 우측이동
      - 모든자리(부호비트 포함)를 오른쪽으로 두칸 옮김
      - 왼쪽 빈자리에서 부호비트는 원상태로 복귀(1이라면 옮기고 난뒤에 다시 1로 채움)
      - 원래 값의 / 4(2^2)를 하는 효과
### 조건연산(3항연산)
  - 조건 ? 값1 : 값2
### 형변환
  - 묵시적 형변환
    - 명확성이 떨어져서 되도록 안쓰는게 좋다.
    - 두 값을 연산했을때 우선순위가 낮은 자료형의 값이 높은 자료형의 값으로 변환 
    - 연산자 단위로 이루어짐
    - 대입 연산자는 값을 저장할 변수의 자료형으로 변환
    - 예)
        - intVar = doubleVar + intVar * floatVar // resultType : int 
          > 위의 경우 아래의 묵시적 형변환 과정을 거쳐 결과는 int 이다.
          - phase 1 : * 연산 : intVar * floatVar // resultType : float
            > 첫번째로 곱셈 연산을 한다. 
            > int보다 float이 우선순위를 가지기 때문에 결과는 float이다  
          - phase 2 : + 연산 : doubleVar + phase1 // resultType : double
            > 두번째로 더하기 연산을 한다.
            > 첫번째 연산 결과인 float보다 double이 우선순위를 가지기 때문에 결과는 double 이다.
          - phase 3 : intVar = phase3 //resultType : int
            > 마지막으로 초기화를 한다.
            > 초기화 변수가 int이기 때문에 double은 int로 저장된다.
  - 명시적 형변환
    - 명확하기 때문에 사용에 용이하다.
    - static_cast : 컴파일 단계에 형변환 처리가 정해짐
    - dynamic_cast : 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 함
    - reinterpret_cast : 관련이 없는 자료형 사이의 변환을 처리, 포인터를 다른 자료형의 포인터, 정수 자료형 또는 그 역으로 변환
    - const_cast: const 지정을 일시 해제함
